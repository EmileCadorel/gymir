#pragma once

#include <ymir/semantic/Symbol.hh>
#include <ymir/semantic/Table.hh>
#include <vector>

namespace semantic {

    /**
     *  Define a reference to a module
     * This is generated by a import instruction
     */
    class ModRef : public ISymbol {

	std::string _name;

	std::shared_ptr<Table> _table;

	Ymir::Lazy <Symbol, ModRef> _module;

	Ymir::Lazy <Symbol, ModRef> _emptyModule;
	
    private :

	friend Symbol;

	ModRef (const lexing::Word & loc, const std::string & comments, const std::string & name, bool isWeak, bool isTrusted);

	ModRef (const ModRef & mod);
	
    public :

	
	static Symbol init (const lexing::Word & loc, const std::string & comments, const std::string & name, bool isWeak, bool isTrusted);
	
	static Symbol init (const lexing::Word & loc, const std::string & comments, const std::vector <std::string> & names, bool isWeak, bool isTrusted);

	void insert (const Symbol & sym) override;
	
	void insertOrReplace (const Symbol & sym) override;

	void insertTemplate (const Symbol & sym) override;
	
	void getTemplates (std::vector<Symbol> & rets) const override;
	
	void getLocal (const std::string & name, std::vector <Symbol> & rets) const override;

	void getLocalPublic (const std::string & name, std::vector <Symbol> & rets) const override;
	
	bool equals (const Symbol & other, bool parent = true) const override;

	/**
	 * \brief Merge two mod reference (assuming they have the same name)
	 * \brief Merge the branch having the same, name 
	 */
	Symbol merge (const ModRef & right) const;
	
	const std::string & getModName () const;

	/**
	 * \return the associated module if this is a leaf (ref to a real module), or this
	 */
	const Ymir::Lazy<Symbol, ModRef> & getModule () const;
	
	/**
	 * \return the space name of this symbol
	 */
	std::string computeRealName () const override;
	
	std::string formatTree (int padd) const override;

	void setReferent (const Symbol &sym) override;

    private:

	Symbol findModule () const;
	
	Symbol emptyModule () const;
	
    };

}
